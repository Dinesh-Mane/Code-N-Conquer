# [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/description/)

## Problem Statement
рдПрдХ integer array nums рджрд┐рд▓рд╛ рдЖрд╣реЗ рдЬреНрдпрд╛рдордзреНрдпреЗ n + 1 elements рдЖрд╣реЗрдд рдЖрдгрд┐ рдкреНрд░рддреНрдпреЗрдХ element 1 рддреЗ n рдЪреНрдпрд╛ рджрд░рдореНрдпрд╛рдирдЪрдВ рдЖрд╣реЗ. рд╣реНрдпрд╛ array рдордзреНрдпреЗ exactly рдПрдХрдЪ number duplicate рдЖрд╣реЗ, рдкрдг рддреЛ рдПрдХрд╛рд╣реВрди рдЕрдзрд┐рдХ рд╡реЗрд│рд╛ рдпреЗрдК рд╢рдХрддреЛ.

ЁЯУМ рдореНрд╣рдгреВрди рддреБрд▓рд╛ duplicate number find рдХрд░рд╛рдпрдЪрд╛ рдЖрд╣реЗ, рдкрдг рд▓рдХреНрд╖рд╛рдд рдареЗрд╡:
> Array modify рдХрд░реВ рдирдпреЗ (рдореНрд╣рдгрдЬреЗ inplace sort, etc. рдирд╛рд╣реА)  
> Extra space O(1) рдЪ рд╡рд╛рдкрд░рд╛рдпрдЪрд╛ рдЖрд╣реЗ (no hashmaps, etc.)

**Example**
```python
Input: nums = [1, 3, 4, 2, 2]
Output: 2
```
```python
Input: nums = [3, 1, 3, 4, 2]
Output: 3
```
## Possible Solutions тАУ Brute Force to Optimized
## 1) Brute Force Approach тАУ Check every pair (O(n┬▓) time, O(1) space)
```python
for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        if nums[i] == nums[j]: return nums[i]
```
## 2) Using Sorting (O(n log n) time but violates space constraint) 
**Idea:** Array sort рдХрд░рд╛. рдЖрдгрд┐ consecutive elements compare рдХрд░рдд рдЬрд╛. рдЬрд░ рджреЛрди element рд╕рд╛рд░рдЦреЗ рдЕрд╕рд▓реЗ, рддрд░ рддреЛрдЪ duplicate.  
```python
nums.sort()  #In-place sort -> space -> O(1) (if in-place sort is allowed)
for i in range(1, len(nums)):
    if nums[i] == nums[i - 1]: return nums[i]
```
```python
nums = sorted(nums)  #creates new copy, not in-place -> space -> O(n)
for i in range(1, len(nums)):
    if nums[i] == nums[i-1]: return nums[i]
```
## 3) Using HashSet (O(n) Time, O(n) Space)
**Logic:** рд╕рд░реНрд╡ numbers рдПрдХрд╛ set рдордзреНрдпреЗ рдШрд╛рд▓рд╛. рдЬрд░ number рдЖрдзреАрдЪ рдЕрд╕рд▓рд╛ рддрд░ рддреЛ duplicate рдЖрд╣реЗ.
```python
hashh = set() #set() madhe lookup O(1) madhe hoto tyamule time khup vachato
for n in nums:
    if n in hashh: return n
    hashh.add(n)
```
## 4) Binary Search on Value Range (O(n log n), O(1) space)
**рд╣реА рдкрджреНрдзрдд array рд╡рд░ binary search рдирд╛рд╣реА рдХрд░рддреЗ, рддрд░ рддреА values рдЪреНрдпрд╛ range рд╡рд░ рдХрд░рддреЗ.**  
> **Logic:**  
> low = 1 рдЖрдгрд┐ high = n (value range)  
> рдкреНрд░рддреНрдпреЗрдХ рд╡реЗрд│реА mid = (low + high) // 2 рдХрд╛рдврд╛  
> рдордЧ array рдордзреНрдпреЗ count рдХрд░рд╛ рдХреА рдХрд┐рддреА numbers рдЖрд╣реЗрдд рдЬреЗ тЙд mid рдЖрд╣реЗрдд  
> If count > mid тЖТ duplicate exists in lower half || Else тЖТ duplicate is in upper half  
> Loop рдЪрд╛рд▓рд╡рдд рд░рд╛рд╣рд╛ рдЬреЛрдкрд░реНрдпрдВрдд low < high  

```
Input: nums = [1, 3, 4, 2, 2]
n = 4, low = 1, high = 4

Iteration 1:
    mid = (1+4)//2 = 2
    count of nums тЙд 2 = 3 (values: 1, 2, 2)
    count > mid тЖТ duplicate is in [1, 2] тЖТ high = mid

Iteration 2:
    mid = (1+2)//2 = 1
    count of nums тЙд 1 = 1
    count == mid тЖТ duplicate in [2,2] тЖТ low = mid+1

low == high == 2 тЖТ duplicate is 2 тЬЕ
```
```python
low = 1
high = len(nums) - 1  # because nums has n+1 elements

while low < high:
    mid = (low + high) // 2
    cnt = sum(n <= mid for n in nums) #array рдордзреВрди рд╕рдЧрд│реА values scan рдХрд░рддреЗ рдЖрдгрд┐ mid рдкреЗрдХреНрд╖рд╛ <= рдХрд┐рддреА elements рдЖрд╣реЗрдд рддреЗ рдореЛрдЬрддреЗ.
    if count > mid: high = mid
    else: low = mid + 1
return low
```
